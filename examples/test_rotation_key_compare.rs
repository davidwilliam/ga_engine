//! CPU vs GPU Rotation Key Comparison
//!
//! Byte-compares rotation keys generated by CPU and GPU to identify divergence.
//!
//! **Run:**
//! ```bash
//! cargo run --release --features v2,v2-gpu-metal,v3 --example test_rotation_key_compare
//! ```

#[cfg(all(feature = "v2", feature = "v2-gpu-metal", feature = "v3"))]
fn main() -> Result<(), String> {
    use ga_engine::clifford_fhe_v2::params::CliffordFHEParams;
    use ga_engine::clifford_fhe_v2::backends::cpu_optimized::keys::KeyContext;
    use ga_engine::clifford_fhe_v2::backends::gpu_metal::rotation_keys::MetalRotationKeys;
    use ga_engine::clifford_fhe_v2::backends::gpu_metal::device::MetalDevice;
    use ga_engine::clifford_fhe_v3::bootstrapping::generate_rotation_keys;
    use std::sync::Arc;

    println!("╔══════════════════════════════════════════════════════════════════════════╗");
    println!("║              CPU vs GPU Rotation Key Byte Comparison                    ║");
    println!("╚══════════════════════════════════════════════════════════════════════════╝\n");

    // Use small parameters for clarity
    let params = CliffordFHEParams::new_v3_bootstrap_metal()?;
    let n = params.n;
    let num_primes = params.moduli.len().min(3); // Use first 3 primes for clarity
    let moduli = &params.moduli[..num_primes];

    println!("Parameters:");
    println!("  N = {}", n);
    println!("  num_primes = {} (using first 3)", num_primes);
    println!("  moduli = {:?}\n", moduli);

    // Generate keys
    println!("Generating encryption keys...");
    let key_ctx = KeyContext::new(params.clone());
    let (_pk, sk, _evk) = key_ctx.keygen();
    println!("✅ Keys generated\n");

    let step = 1i32;
    let base_w = 20u32;  // Must match CPU's hardcoded base_w

    // ========== CPU Rotation Keys ==========
    println!("═══════════════════════════════════════════════════════════════════════════");
    println!("CPU Rotation Key Generation");
    println!("═══════════════════════════════════════════════════════════════════════════\n");

    let cpu_rot_keys = generate_rotation_keys(&vec![step], &sk, &params);

    // Extract CPU keys - they're stored in a different format, so we need to access them
    // For now, just note that CPU generates them
    println!("✅ CPU rotation keys generated\n");

    // ========== GPU Rotation Keys ==========
    println!("═══════════════════════════════════════════════════════════════════════════");
    println!("GPU Rotation Key Generation");
    println!("═══════════════════════════════════════════════════════════════════════════\n");

    let metal_device = Arc::new(MetalDevice::new()?);
    let metal_ntt_contexts = create_metal_ntt_contexts(&params, metal_device.clone())?;

    let gpu_rot_keys = MetalRotationKeys::generate(
        metal_device.clone(),
        &sk,
        &[step],
        &params,
        &metal_ntt_contexts,
        base_w,
    )?;

    println!("✅ GPU rotation keys generated\n");

    // ========== Comparison ==========
    println!("═══════════════════════════════════════════════════════════════════════════");
    println!("Key Comparison");
    println!("═══════════════════════════════════════════════════════════════════════════\n");

    // Get GPU keys (coefficient domain, before any NTT transforms)
    let (gpu_rlk0, gpu_rlk1) = gpu_rot_keys.get_key_for_step(step)
        .ok_or("GPU rotation key not found")?;

    let num_digits = gpu_rlk0.len();
    println!("Number of digits: {}", num_digits);
    println!("base_w: {} (B = 2^{})\n", base_w, base_w);

    // GPU keys are in flat RNS layout: [coeff0_mod_q0, coeff0_mod_q1, ..., coeff0_mod_qL, coeff1_mod_q0, ...]
    // Each digit has n*num_primes_total values

    let gpu_num_primes_in_key = gpu_rlk0[0].len() / n;
    println!("GPU key structure:");
    println!("  rlk0[0].len() = {} ({} coeffs × {} primes)", gpu_rlk0[0].len(), n, gpu_num_primes_in_key);
    println!("  rlk1[0].len() = {} ({} coeffs × {} primes)\n", gpu_rlk1[0].len(), n, gpu_num_primes_in_key);

    // Show GPU key values (first 2 digits, first 4 coeffs, first 2 primes)
    dump_rlk("GPU", &gpu_rlk0, &gpu_rlk1, n, gpu_num_primes_in_key);

    // Extract CPU keys to flat layout for comparison
    println!("\n═══════════════════════════════════════════════════════════════════════════");
    println!("Extracting CPU Keys");
    println!("═══════════════════════════════════════════════════════════════════════════\n");

    // Get CPU key for galois element g=5
    let g = 5usize; // For step=1, g=5
    let cpu_key = cpu_rot_keys.get_key(g)
        .ok_or("CPU rotation key for g=5 not found")?;

    println!("CPU key structure:");
    println!("  Galois element: {}", cpu_key.galois_element);
    println!("  base_w: {}", cpu_key.base_w);
    println!("  rlk0.len() (num digits): {}", cpu_key.rlk0.len());
    println!("  rlk0[0].len() (num coeffs): {}", cpu_key.rlk0[0].len());
    println!("  rlk0[0][0].values.len() (num primes): {}\n", cpu_key.rlk0[0][0].values.len());

    // Convert CPU keys to flat layout (first 3 primes only)
    let cpu_num_primes = cpu_key.rlk0[0][0].values.len();
    let num_primes_to_compare = 3.min(cpu_num_primes).min(gpu_num_primes_in_key);

    println!("Converting CPU keys to flat layout (using first {} primes)...", num_primes_to_compare);

    let mut cpu_rlk0_flat: Vec<Vec<u64>> = Vec::new();
    let mut cpu_rlk1_flat: Vec<Vec<u64>> = Vec::new();

    for digit in 0..cpu_key.rlk0.len() {
        let mut rlk0_d = vec![0u64; n * num_primes_to_compare];
        let mut rlk1_d = vec![0u64; n * num_primes_to_compare];

        for coeff_idx in 0..n {
            for prime_idx in 0..num_primes_to_compare {
                let flat_idx = coeff_idx * num_primes_to_compare + prime_idx;
                rlk0_d[flat_idx] = cpu_key.rlk0[digit][coeff_idx].values[prime_idx];
                rlk1_d[flat_idx] = cpu_key.rlk1[digit][coeff_idx].values[prime_idx];
            }
        }

        cpu_rlk0_flat.push(rlk0_d);
        cpu_rlk1_flat.push(rlk1_d);
    }

    println!("✅ CPU keys converted to flat layout\n");

    dump_rlk("CPU", &cpu_rlk0_flat, &cpu_rlk1_flat, n, num_primes_to_compare);

    println!("\n═══════════════════════════════════════════════════════════════════════════");
    println!("Byte Comparison");
    println!("═══════════════════════════════════════════════════════════════════════════\n");

    let num_digits_to_compare = 2.min(cpu_rlk0_flat.len()).min(gpu_rlk0.len());

    let mut all_match = true;
    let mut first_mismatch_shown = false;

    for digit in 0..num_digits_to_compare {
        for coeff in 0..4 {  // Compare first 4 coefficients
            for prime in 0..num_primes_to_compare {
                let idx = coeff * num_primes_to_compare + prime;
                let cpu_val_rlk0 = cpu_rlk0_flat[digit][idx];
                let gpu_val_rlk0 = gpu_rlk0[digit][coeff * gpu_num_primes_in_key + prime];

                let cpu_val_rlk1 = cpu_rlk1_flat[digit][idx];
                let gpu_val_rlk1 = gpu_rlk1[digit][coeff * gpu_num_primes_in_key + prime];

                if cpu_val_rlk0 != gpu_val_rlk0 {
                    all_match = false;
                    if !first_mismatch_shown {
                        println!("❌ MISMATCH in rlk0[digit={}, coeff={}, prime={}]:", digit, coeff, prime);
                        println!("   CPU: {}", cpu_val_rlk0);
                        println!("   GPU: {}", gpu_val_rlk0);
                        first_mismatch_shown = true;
                    }
                }

                if cpu_val_rlk1 != gpu_val_rlk1 {
                    all_match = false;
                    if !first_mismatch_shown {
                        println!("❌ MISMATCH in rlk1[digit={}, coeff={}, prime={}]:", digit, coeff, prime);
                        println!("   CPU: {}", cpu_val_rlk1);
                        println!("   GPU: {}", gpu_val_rlk1);
                        first_mismatch_shown = true;
                    }
                }
            }
        }
    }

    println!();
    if all_match {
        println!("✅ PERFECT MATCH - CPU and GPU rotation keys are identical!");
        println!("   Bug must be in key switching logic, not key generation.");
    } else {
        println!("❌ KEYS DIFFER - Bug is in rotation key generation!");
        println!("   Need to check which term (bt_sk, neg_at_s, or e_t) is wrong.");
    }

    Ok(())
}

#[cfg(all(feature = "v2", feature = "v2-gpu-metal", feature = "v3"))]
fn dump_rlk(prefix: &str, rlk0: &[Vec<u64>], rlk1: &[Vec<u64>], _n: usize, num_primes: usize) {
    println!("{} Rotation Key Values:", prefix);

    // Show first 2 digits
    for d in 0..2.min(rlk0.len()) {
        println!("\n  Digit {}:", d);

        // Show first 4 coefficients, first 2 primes
        for p in 0..2.min(num_primes) {
            print!("    rlk0[d={}] p{} coeff[0..4] = [", d, p);
            for i in 0..4 {
                let idx = i * num_primes + p;
                if idx < rlk0[d].len() {
                    print!("{}", rlk0[d][idx]);
                    if i < 3 { print!(", "); }
                }
            }
            println!("]");

            print!("    rlk1[d={}] p{} coeff[0..4] = [", d, p);
            for i in 0..4 {
                let idx = i * num_primes + p;
                if idx < rlk1[d].len() {
                    print!("{}", rlk1[d][idx]);
                    if i < 3 { print!(", "); }
                }
            }
            println!("]");
        }
    }
}

#[cfg(all(feature = "v2", feature = "v2-gpu-metal", feature = "v3"))]
fn create_metal_ntt_contexts(
    params: &ga_engine::clifford_fhe_v2::params::CliffordFHEParams,
    device: std::sync::Arc<ga_engine::clifford_fhe_v2::backends::gpu_metal::device::MetalDevice>,
) -> Result<Vec<ga_engine::clifford_fhe_v2::backends::gpu_metal::ntt::MetalNttContext>, String> {
    use ga_engine::clifford_fhe_v2::backends::gpu_metal::ntt::MetalNttContext;

    let mut contexts = Vec::new();
    for &q in &params.moduli {
        let psi = find_primitive_2n_root(params.n, q)?;
        let ctx = MetalNttContext::new_with_device(device.clone(), params.n, q, psi)?;
        contexts.push(ctx);
    }
    Ok(contexts)
}

#[cfg(all(feature = "v2", feature = "v2-gpu-metal", feature = "v3"))]
fn find_primitive_2n_root(n: usize, q: u64) -> Result<u64, String> {
    let two_n = (2 * n) as u64;
    if (q - 1) % two_n != 0 {
        return Err(format!("q = {} is not NTT-friendly for n = {}", q, n));
    }

    let exp = (q - 1) / two_n;

    for g in [2u64, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31] {
        let psi = pow_mod(g % q, exp, q);
        if psi != 1
            && pow_mod(psi, two_n, q) == 1
            && pow_mod(psi, n as u64, q) != 1
        {
            return Ok(psi);
        }
    }

    Err(format!("Could not find primitive 2N-th root for n = {}, q = {}", n, q))
}

#[cfg(all(feature = "v2", feature = "v2-gpu-metal", feature = "v3"))]
fn pow_mod(mut base: u64, mut exp: u64, modulus: u64) -> u64 {
    let mut result = 1u64;
    base %= modulus;
    while exp > 0 {
        if exp % 2 == 1 {
            result = ((result as u128 * base as u128) % modulus as u128) as u64;
        }
        base = ((base as u128 * base as u128) % modulus as u128) as u64;
        exp /= 2;
    }
    result
}

#[cfg(not(all(feature = "v2", feature = "v2-gpu-metal", feature = "v3")))]
fn main() {
    println!("This example requires features: v2, v2-gpu-metal, v3");
    println!("Run with: cargo run --release --features v2,v2-gpu-metal,v3 --example test_rotation_key_compare");
}
